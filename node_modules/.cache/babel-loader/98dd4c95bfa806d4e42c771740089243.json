{"remainingRequest":"/Users/yanglina/wadmin/node_modules/_babel-loader@8.0.6@babel-loader/lib/index.js!/Users/yanglina/wadmin/src/store/module/app.js","dependencies":[{"path":"/Users/yanglina/wadmin/src/store/module/app.js","mtime":1576046288964},{"path":"/Users/yanglina/wadmin/node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/yanglina/wadmin/node_modules/_babel-loader@8.0.6@babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import { getBreadCrumbList, setTagNavListInLocalstorage, getMenuByRouter, getTagNavListFromLocalstorage, getHomeRoute, getNextRoute, routeHasExist, routeEqual, getRouteTitleHandled, localSave, localRead } from '@/libs/util';\nimport beforeClose from '@/router/before-close';\nimport router from '@/router';\nimport routers from '@/router/routers';\nimport config from '@/config';\nimport routes from '../../router/routers';\nconst {\n  homeName\n} = config;\n\nconst closePage = (state, route) => {\n  const nextRoute = getNextRoute(state.tagNavList, route);\n  state.tagNavList = state.tagNavList.filter(item => {\n    return !routeEqual(item, route);\n  });\n  router.push(nextRoute);\n};\n\nexport default {\n  state: {\n    breadCrumbList: [],\n    tagNavList: [],\n    homeRoute: getHomeRoute(routers, homeName),\n    local: localRead('local'),\n    errorList: [],\n    hasReadErrorPage: false\n  },\n  getters: {\n    menuList: (state, getters, rootState) => getMenuByRouter(routes, rootState.user.access),\n    errorCount: state => state.errorList.length\n  },\n  mutations: {\n    setBreadCrumb(state, route) {\n      state.breadCrumbList = getBreadCrumbList(route, state.homeRoute);\n    },\n\n    setTagNavList(state, list) {\n      let tagList = [];\n\n      if (list) {\n        tagList = [...list];\n      } else {\n        tagList = getTagNavListFromLocalstorage() || [];\n      }\n\n      if (tagList[0] && tagList[0].name !== homeName) tagList.shift();\n      let homeTagIndex = tagList.findIndex(item => item.name === homeName);\n\n      if (homeTagIndex > 0) {\n        let homeTag = tagList.splice(homeTagIndex, 1)[0];\n        tagList.unshift(homeTag);\n      }\n\n      state.tagNavList = tagList;\n      setTagNavListInLocalstorage([...tagList]);\n    },\n\n    closeTag(state, route) {\n      let tag = state.tagNavList.filter(item => routeEqual(item, route));\n      route = tag[0] ? tag[0] : null;\n      if (!route) return;\n\n      if (route.meta && route.meta.beforeCloseName && route.meta.beforeCloseName in beforeClose) {\n        new Promise(beforeClose[route.meta.beforeCloseName]).then(close => {\n          if (close) {\n            closePage(state, route);\n          }\n        });\n      } else {\n        closePage(state, route);\n      }\n    },\n\n    addTag(state, {\n      route,\n      type = 'unshift'\n    }) {\n      let router = getRouteTitleHandled(route);\n\n      if (!routeHasExist(state.tagNavList, router)) {\n        if (type === 'push') {\n          state.tagNavList.push(router);\n        } else {\n          if (router.name === homeName) {\n            state.tagNavList.unshift(router);\n          } else {\n            state.tagNavList.splice(1, 0, router);\n          }\n        }\n\n        setTagNavListInLocalstorage([...state.tagNavList]);\n      }\n    },\n\n    setLocal(state, lang) {\n      localSave('local', lang);\n      state.local = lang;\n    },\n\n    addError(state, error) {\n      state.errorList.push(error);\n    },\n\n    setHasReadErrorLoggerStatus(state, status = true) {\n      state.hasReadErrorPage = status;\n    }\n\n  },\n  actions: {\n    addErrorLog({\n      commit,\n      rootState\n    }, info) {\n      if (!window.location.href.includes('error_logger_page')) commit('setHasReadErrorLoggerStatus', false);\n      const {\n        user: {\n          token,\n          userId,\n          userName\n        }\n      } = rootState;\n      let data = { ...info,\n        time: Date.parse(new Date()),\n        token,\n        userId,\n        userName\n      };\n      commit('addError', data);\n      /* saveErrorLogger(info).then(() => {\n        commit('addError', data)\n      }) */\n    }\n\n  }\n};",{"version":3,"sources":["/Users/yanglina/wadmin/src/store/module/app.js"],"names":["getBreadCrumbList","setTagNavListInLocalstorage","getMenuByRouter","getTagNavListFromLocalstorage","getHomeRoute","getNextRoute","routeHasExist","routeEqual","getRouteTitleHandled","localSave","localRead","beforeClose","router","routers","config","routes","homeName","closePage","state","route","nextRoute","tagNavList","filter","item","push","breadCrumbList","homeRoute","local","errorList","hasReadErrorPage","getters","menuList","rootState","user","access","errorCount","length","mutations","setBreadCrumb","setTagNavList","list","tagList","name","shift","homeTagIndex","findIndex","homeTag","splice","unshift","closeTag","tag","meta","beforeCloseName","Promise","then","close","addTag","type","setLocal","lang","addError","error","setHasReadErrorLoggerStatus","status","actions","addErrorLog","commit","info","window","location","href","includes","token","userId","userName","data","time","Date","parse"],"mappings":"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","sourcesContent":["import {\n  getBreadCrumbList,\n  setTagNavListInLocalstorage,\n  getMenuByRouter,\n  getTagNavListFromLocalstorage,\n  getHomeRoute,\n  getNextRoute,\n  routeHasExist,\n  routeEqual,\n  getRouteTitleHandled,\n  localSave,\n  localRead\n} from '@/libs/util'\nimport beforeClose from '@/router/before-close'\n\nimport router from '@/router'\nimport routers from '@/router/routers'\nimport config from '@/config'\nimport routes from '../../router/routers'\n\nconst { homeName } = config\n\nconst closePage = (state, route) => {\n  const nextRoute = getNextRoute(state.tagNavList, route)\n  state.tagNavList = state.tagNavList.filter(item => {\n    return !routeEqual(item, route)\n  })\n  router.push(nextRoute)\n}\n\nexport default {\n  state: {\n    breadCrumbList: [],\n    tagNavList: [],\n    homeRoute: getHomeRoute(routers, homeName),\n    local: localRead('local'),\n    errorList: [],\n    hasReadErrorPage: false\n  },\n  getters: {\n    menuList: (state, getters, rootState) => getMenuByRouter(routes, rootState.user.access),\n    errorCount: state => state.errorList.length\n  },\n  mutations: {\n    setBreadCrumb (state, route) {\n      state.breadCrumbList = getBreadCrumbList(route, state.homeRoute)\n    },\n    setTagNavList (state, list) {\n      let tagList = []\n      if (list) {\n        tagList = [...list]\n      } else {\n        tagList = getTagNavListFromLocalstorage() || []\n      }\n      if (tagList[0] && tagList[0].name !== homeName) tagList.shift()\n      let homeTagIndex = tagList.findIndex(item => item.name === homeName)\n      if (homeTagIndex > 0) {\n        let homeTag = tagList.splice(homeTagIndex, 1)[0]\n        tagList.unshift(homeTag)\n      }\n      state.tagNavList = tagList\n      setTagNavListInLocalstorage([...tagList])\n    },\n    closeTag (state, route) {\n      let tag = state.tagNavList.filter(item => routeEqual(item, route))\n      route = tag[0] ? tag[0] : null\n      if (!route) return\n      if (route.meta && route.meta.beforeCloseName && route.meta.beforeCloseName in beforeClose) {\n        new Promise(beforeClose[route.meta.beforeCloseName]).then(close => {\n          if (close) {\n            closePage(state, route)\n          }\n        })\n      } else {\n        closePage(state, route)\n      }\n    },\n    addTag (state, { route, type = 'unshift' }) {\n      let router = getRouteTitleHandled(route)\n      if (!routeHasExist(state.tagNavList, router)) {\n        if (type === 'push') {\n          state.tagNavList.push(router)\n        } else {\n          if (router.name === homeName) {\n            state.tagNavList.unshift(router)\n          } else {\n            state.tagNavList.splice(1, 0, router)\n          }\n        }\n        setTagNavListInLocalstorage([...state.tagNavList])\n      }\n    },\n    setLocal (state, lang) {\n      localSave('local', lang)\n      state.local = lang\n    },\n    addError (state, error) {\n      state.errorList.push(error)\n    },\n    setHasReadErrorLoggerStatus (state, status = true) {\n      state.hasReadErrorPage = status\n    }\n  },\n  actions: {\n    addErrorLog ({ commit, rootState }, info) {\n      if (!window.location.href.includes('error_logger_page')) commit('setHasReadErrorLoggerStatus', false)\n      const { user: { token, userId, userName } } = rootState\n      let data = {\n        ...info,\n        time: Date.parse(new Date()),\n        token,\n        userId,\n        userName\n      }\n      commit('addError', data)\n      /* saveErrorLogger(info).then(() => {\n        commit('addError', data)\n      }) */\n    }\n  }\n}\n"]}]}